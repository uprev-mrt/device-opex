/**
  * @file opex_slave.h
  * @author generated by mrt-device utility 
  * @link [https://github.com/uprev-mrt/mrtutils/wiki/mrt-device]
  * @brief Device driver for opex device
  *
  *
  *  ***CODE BETWEEN gen-block-x-* TAGS ARE OVERWRITTEN ON UPDATES***
  */

#ifdef __cplusplus
extern "C"
{
#endif

#include <stdint.h>
#include "opex_regs.h"


#define SLAVE_REG_PERM_R    0x01
#define SLAVE_REG_PERM_W    0x02
#define SLAVE_REG_PERM_X    0x04
#define SLAVE_REG_PERM_RW   0x03

#define SLAVE_REG_ACESS_R             0x80
#define SLAVE_REG_ACESS_W             0x40
#define SLAVE_REG_ACESS_W_COMPLETE    0x20

#define SLAVE_STATE_ADDRESS  0x00
#define SLAVE_STATE_DATA     0x01

/*******************************************************************************
  Struct                                                                                
*******************************************************************************/
typedef uint8_t addr_t;

typedef struct slave_reg_t slave_reg_t;

typedef uint8_t (*regOpHandler)(slave_reg_t* reg); 

struct slave_reg_t{
    uint8_t mFlags;
    uint8_t mSize;
    addr_t mAddr;
} ;




typedef struct{
    /*gen-block-mdata-start*/
    struct
    {
        uint32_t mGpioIn;                             //Input values for gpio 0-25
        uint32_t mGpioOut;                            //Output values for gpio 0-15
        uint32_t mGpioDdr;                            //Direction Register for GPIO
        uint32_t mIrqSrc;                             //latching Interrupt source mask. indicates souce of IRQ resets on read
        uint16_t mAdc0Val;                            //Output of ADC 0
        uint16_t mAdc1Val;                            //Output of ADC 1
        uint16_t mAdc2Val;                            //Output of ADC 2
        uint16_t mAdc3Val;                            //Output of ADC 3
        uint16_t mAdc4Val;                            //Output of ADC 4
        uint16_t mPwm0Val;                            //PWM value for ch 0
        uint16_t mPwm1Val;                            //PWM value for ch 1
        uint16_t mPwm2Val;                            //PWM value for ch 2
        uint16_t mPwm3Val;                            //PWM value for ch 3
        uint16_t mPwm4Val;                            //PWM value for ch 4
        uint16_t mPwm5Val;                            //PWM value for ch 5
        uint8_t mGpio0Cfg;                            //Configuration for GPIO 0
        uint8_t mGpio1Cfg;                            //Configuration for GPIO 1
        uint8_t mGpio2Cfg;                            //Configuration for GPIO 2
        uint8_t mGpio3Cfg;                            //Configuration for GPIO 3
        uint8_t mGpio4Cfg;                            //Configuration for GPIO 4
        uint8_t mGpio5Cfg;                            //Configuration for GPIO 5
        uint8_t mGpio6Cfg;                            //Configuration for GPIO 6
        uint8_t mGpio7Cfg;                            //Configuration for GPIO 7
        uint8_t mGpio8Cfg;                            //Configuration for GPIO 8
        uint8_t mGpio9Cfg;                            //Configuration for GPIO 9
        uint8_t mGpio10Cfg;                           //Configuration for GPIO 10
        uint8_t mGpio11Cfg;                           //Configuration for GPIO 11
        uint8_t mGpio12Cfg;                           //Configuration for GPIO 12
        uint8_t mGpio13Cfg;                           //Configuration for GPIO 13
        uint8_t mGpio14Cfg;                           //Configuration for GPIO 14
        uint8_t mGpio15Cfg;                           //Configuration for GPIO 15
        uint8_t mGpio16Cfg;                           //Configuration for GPIO 16
        uint8_t mGpio17Cfg;                           //Configuration for GPIO 17
        uint8_t mGpio18Cfg;                           //Configuration for GPIO 18
        uint8_t mGpio19Cfg;                           //Configuration for GPIO 19
        uint8_t mGpio20Cfg;                           //Configuration for GPIO 20
        uint8_t mGpio21Cfg;                           //Configuration for GPIO 21
        uint8_t mGpio22Cfg;                           //Configuration for GPIO 22
        uint8_t mGpio23Cfg;                           //Configuration for GPIO 23
        uint8_t mGpio24Cfg;                           //Configuration for GPIO 24
        uint8_t mGpio25Cfg;                           //Configuration for GPIO 25
        uint16_t mIrqCfg;                             //IRQ Configuration
        uint16_t mAdc0Cfg;                            //Configuration for ADC 0
        uint16_t mAdc1Cfg;                            //Configuration for ADC 1
        uint16_t mAdc2Cfg;                            //Configuration for ADC 2
        uint16_t mAdc3Cfg;                            //Configuration for ADC 3
        uint16_t mAdc4Cfg;                            //Configuration for ADC 4
        uint32_t mPwmConfig;                          //Configuration for PWM
        uint8_t mWhoAmI;                              //Device ID
        uint32_t mVersion;                            //Version of firmware
        uint8_t mEepromMem;                           //Start address of EEPROM memory on stm8. User can read/write up to 128 bytes starting at this address
    } mData;    
    /*gen-block-mdata-end*/
    slave_reg_t mRegs[OPEX_REG_COUNT];
    slave_reg_t* mCurrentReg;
    uint8_t mCursor;        //Register cursor
    uint8_t mAddrBytes;     //Number of address bytes received so far
    addr_t mAddress;        //Current address
    uint8_t mState;         //state of register server
    uint8_t mFlags;         //flags for handling
}opex_slave_t;

#pragma pack(pop)


/**
 * @brief initializes opex slave registers
 * @param fifoDepth size of rxFifo to use
 */
void io_slave_init();

/**
 * @brief feed byte into device
 * @param data byte to feed 
 */
void io_slave_put( uint8_t data );

/**
 * @brief gets next byte
 * @param data byte to feed 
 */
uint8_t io_slave_get(void);

/**
 * @brief ends transaction and resets state
 * 
 */
void io_slave_end_transaction(void);

/**
 * @brief write handler
 * 
 */
void io_slave_handle_write( slave_reg_t* reg);

#ifdef __cplusplus
}
#endif